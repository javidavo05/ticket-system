import { createServiceRoleClient } from '@/lib/supabase/server'
import { NotFoundError, ValidationError } from '@/lib/utils/errors'
import { generateSecurityToken, generateBindingChallenge, verifyBinding } from './tokens'

/**
 * Binding challenge storage (in-memory for now, could be moved to Redis in production)
 * Maps bandId -> { challenge, expiresAt, userId }
 */
const bindingChallenges = new Map<
  string,
  { challenge: string; expiresAt: number; userId: string }
>()

// Challenge expiration: 5 minutes
const CHALLENGE_EXPIRY_MS = 5 * 60 * 1000

/**
 * Initiate binding process for NFC band
 * @param bandUid - The NFC band UID
 * @param userId - The user ID to bind to
 * @returns Challenge string for verification
 */
export async function initiateBinding(bandUid: string, userId: string): Promise<string> {
  const supabase = await createServiceRoleClient()

  // Check if band exists
  const { data: band, error } = await supabase
    .from('nfc_bands')
    .select('id, user_id, status')
    .eq('band_uid', bandUid)
    .single()

  if (error || !band) {
    throw new NotFoundError('NFC band')
  }

  if (band.status !== 'active') {
    throw new ValidationError(`NFC band is ${band.status}`)
  }

  // Verify user owns the band or is binding it
  if (band.user_id && band.user_id !== userId) {
    throw new ValidationError('NFC band is already bound to another user')
  }

  // Generate challenge
  const challenge = generateBindingChallenge()
  const expiresAt = Date.now() + CHALLENGE_EXPIRY_MS

  // Store challenge
  bindingChallenges.set(band.id, {
    challenge,
    expiresAt,
    userId,
  })

  // Clean up expired challenges periodically
  cleanupExpiredChallenges()

  return challenge
}

/**
 * Complete binding process with challenge-response verification
 * @param bandId - The NFC band ID
 * @param challenge - Challenge string from initiateBinding
 * @param response - Response string (generated by reading band UID)
 * @returns Security token if binding successful
 */
export async function completeBinding(
  bandId: string,
  challenge: string,
  response: string
): Promise<string> {
  const supabase = await createServiceRoleClient()

  // Get stored challenge
  const stored = bindingChallenges.get(bandId)
  if (!stored) {
    throw new ValidationError('Binding challenge not found or expired')
  }

  if (stored.expiresAt < Date.now()) {
    bindingChallenges.delete(bandId)
    throw new ValidationError('Binding challenge expired')
  }

  if (stored.challenge !== challenge) {
    throw new ValidationError('Invalid binding challenge')
  }

  // Verify binding
  const verified = await verifyBinding(bandId, challenge, response)
  if (!verified) {
    throw new ValidationError('Binding verification failed')
  }

  // Update band user_id if not set
  const { data: band } = await supabase
    .from('nfc_bands')
    .select('user_id')
    .eq('id', bandId)
    .single()

  if (band && !band.user_id) {
    await supabase
      .from('nfc_bands')
      .update({
        user_id: stored.userId,
      })
      .eq('id', bandId)
  }

  // Remove challenge
  bindingChallenges.delete(bandId)

  // Generate security token
  const token = await generateSecurityToken(bandId)

  return token
}

/**
 * Verify that user owns the NFC band
 * @param bandId - The NFC band ID
 * @param userId - The user ID to verify
 * @returns True if user owns the band
 */
export async function verifyBindingOwnership(bandId: string, userId: string): Promise<boolean> {
  const supabase = await createServiceRoleClient()

  const { data: band, error } = await supabase
    .from('nfc_bands')
    .select('user_id, binding_verified_at')
    .eq('id', bandId)
    .single()

  if (error || !band) {
    return false
  }

  // Check user ownership
  if (band.user_id !== userId) {
    return false
  }

  // Check if binding was verified
  if (!band.binding_verified_at) {
    return false
  }

  return true
}

/**
 * Clean up expired binding challenges
 */
function cleanupExpiredChallenges(): void {
  const now = Date.now()
  for (const [bandId, challenge] of bindingChallenges.entries()) {
    if (challenge.expiresAt < now) {
      bindingChallenges.delete(bandId)
    }
  }
}

/**
 * Get binding challenge for a band (if exists)
 * @param bandId - The NFC band ID
 * @returns Challenge string or null
 */
export function getBindingChallenge(bandId: string): string | null {
  const stored = bindingChallenges.get(bandId)
  if (!stored || stored.expiresAt < Date.now()) {
    return null
  }
  return stored.challenge
}
